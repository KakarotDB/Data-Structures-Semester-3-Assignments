#include <stdio.h>
#include <stdlib.h>
#include "Stack.h"
#include <ctype.h>
#include <string.h>
int main() {
	//#idea 
	//Read inputted string from right to left
	//Use same postfix evaluation algorithm except operand1 = first pop, operand2 = second pop
	//Now, Parsing the string?
	//We go from right to left, go till index of first white space.
	//From this index, we add the string till we encounter the next whitespace, and check if it's a
	//number or an operator. 
	int result = 0;
	char expression[514];
	int size = 512;
	int i = 0;
	int index = 0;
	int count = 0;
	char number[12];
	int operand1 = 0;
	int operand2 = 0;
	stack *eval = (stack *) malloc(sizeof(stack));
	int operationFlag = -1;
	operationFlag = initialize(eval, size);
	if(0 == operationFlag) {
		printf("Unable to initialize stack\n");
		return -1;
	}
	else
		printf("Stack successfully initialized with size %d\n", size);
	printf("Enter the prefix expression to be evaluated (separated by whitespace) :\n");
	fgets(expression, sizeof(expression), stdin);
	expression[strcspn(expression, "\n")] = '\0';
	for(i = 0; expression[i] != '\0'; i++); //finding length of inputted string
	i--; //this is the last index just before the null character of inputted string 
	for(; i >= 0; i--) {
		if(isspace(expression[i])) {
			continue;
		}
		if(isdigit(expression[i])) {
			count = i;
			while(!isspace(expression[count])) {
				count--;
			}
			printf("Count before incrementing : %d\n", count);
			count++;
			printf("count after incrementing = %d\n", count);
			while(!isspace(expression[count]) || expression[count] != '\0') {
				number[index] = expression[count];
				count++;
				index++;
			}
			number[index + 1] = '\0';
			printf("%s\n", number);
			operationFlag = push(eval, atoi(number), size);
			if(0 == operationFlag) {
				printf("Was not able to push element!\n");
				return -1;
			}
			index = 0;
		}
		if(!isdigit(expression[i])) {
			operationFlag = pop(eval, &operand1);
			if(0 == operationFlag) {
				printf("Invalid expression! Could not pop operand1\n");
				return -1;
			}
			operationFlag = pop(eval, &operand2);
			if(0 == operationFlag) {
				printf("Invalid expression! Could not pop operand2\n");
				return -1;
			}
			switch(expression[i]) {
				case '+' :
					operationFlag = push(eval, operand1 + operand2, size);
					if(0 == operationFlag) {
						printf("Could not push sum operation!\n");
						return -1;
					}
					break;
				case '*' :
					operationFlag = push(eval, operand1 * operand2, size);
					if(0 == operationFlag) {
						printf("Could not push multiplication operation!\n");
						return -1;
					}
					break;
				case '-' :
					operationFlag = push(eval, operand1 - operand2, size);
					if(0 == operationFlag) {
						printf("Could not push difference operation!\n");
						return -1;
					}
					break;
				case '/' :
					if(operand2 == 0) {
						printf("Division by zero not possible!\n");
						return -1;
					}
					operationFlag = push(eval, operand1 / operand2, size);
					if(0 == operationFlag) {
						printf("Could not push division operation!\n");
						return -1;
					}
				default :
					printf("Invalid prefix expression!\n");
					break;
			}
		}
		operationFlag = pop(eval, &result);
		if(0 == operationFlag) {
			printf("Could not get result!\n");
			return -1;
		}
		if(isEmpty(eval) == 0) {
			printf("Invalid expression!\n");
			return -1;
		}
		printf("Result = %d\n", result);
		return 0;
	}
}
